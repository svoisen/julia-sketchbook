using Luxor, GeoInterface, GeometryOps, GeometryBasics, Plotline, CatmullRom

width = 8inch
height = 10inch
margin = 0.5inch
multiplier = 6.0
sun_radius_slop = 0.05inch
sun_radius = 1inch
num_ridges = 3
draw_sun = true

"""
    random_between(min_val::Float64, max_val::Float64)

Generate a random float between `min_val` and `max_val`.
"""
function random_between(min_val, max_val)
    return min_val + rand() * (max_val - min_val)
end

"""
    randomcurve(starty::Float64, startx::Float64, endx::Float64, multiplier::Float64 = 10.0)

Generate a random curve between two points, starting at `starty` and `startx` and ending at `endx`.
The curve is generated by adding random noise to the y-coordinate.
"""
function randomcurve(start::Luxor.Point, endx::Float64, multiplier::Float64 = 10.0)
    xs = range(start.x, endx, 50)
    ys = Vector{Float64}(undef, length(xs))
    y = start.y
    for i in 1:length(xs)
        y += randn() * multiplier
        ys[i] = y
    end

    return collect(zip(xs, ys))
end

"""
    createridge(w::Float64, h::Float64, multiplier::Float64=10.0)

Create a closed polygon representing a ridge with a random curve at the top.
"""
function createridge(upperleft::Luxor.Point, lowerright::Luxor.Point, multiplier::Float64=10.0)
    polygon_points = randomcurve(upperleft, lowerright.x, multiplier)
    
    push!(polygon_points, (lowerright.x, lowerright.y))
    push!(polygon_points, (upperleft.x, lowerright.y))
    push!(polygon_points, first(polygon_points))
    
    polygon_points = [GeometryBasics.Point2d(p[1], p[2]) for p in polygon_points]
    return GeometryOps.Polygon(polygon_points)
end

function createsun(origin::Luxor.Point, radius::Float64, radius_slop::Float64)
    points = Vector{GeometryBasics.Point2d}()
    for angle in 0:π/6:2π - π/6
        r = radius + random_between(-radius_slop, radius_slop)
        x = origin.x + r * cos(angle)
        y = origin.y + r * sin(angle)
        push!(points, (x, y))
    end

    close_seq!(points)
    cxs, cys = catmullrom_by_arclength(points)
    return GeometryOps.Polygon([GeometryBasics.Point2d(x, y) for (x, y) in collect(zip(cxs, cys))])
end

@draw begin
    Luxor.origin(0, 0)
    background("white")
    setline(0.5)
    colors = ["orange", "green", "blue"]

    # Algorithm:
    # 1. Draw the first ridge entirely at the lowest y position.
    # 2. For each subsequent ridge, compute the difference with the previously drawn area.
    # 3. Draw only the difference between the new ridge and previously drawn area.
    # 4. Update the drawn area by taking the union with the current ridge.
    # 5. Repeat for the next ridge, moving upwards on the page.

    local drawn_area = nothing
    local y = margin + height * 0.75

    for i in 1:num_ridges
        sethue(colors[i])
        upperleft = Luxor.Point(margin, y)
        lowerright = Luxor.Point(width - margin, height - margin)
        
        current_ridge = createridge(upperleft, lowerright, multiplier)
        
        local points::Vector{Luxor.Point} = []
        if drawn_area === nothing
            points = [Luxor.Point(coord[1], coord[2]) for coord in GeoInterface.coordinates(current_ridge)[1]]
            drawn_area = current_ridge
        else
            ridge_difference = GeometryOps.difference(current_ridge, drawn_area, target = GeoInterface.PolygonTrait())
            points = [Luxor.Point(coord[1], coord[2]) for coord in GeoInterface.coordinates(ridge_difference[1])[1]]
            drawn_area = GeometryOps.union(drawn_area, current_ridge, target = GeoInterface.PolygonTrait())[1]
        end

        hatch(poly(points, :stroke), 45, 2.0)
        
        # Move up for the next ridge
        if i < num_ridges
            y -= height * random_between(0.05, 0.3)
        end
    end

    if draw_sun
        sethue("red")
        sun = createsun(Luxor.Point(width / 2, y), sun_radius, sun_radius_slop)
        sun_difference = GeometryOps.difference(sun, drawn_area, target = GeoInterface.PolygonTrait())[1]
        points = [Luxor.Point(coord[1], coord[2]) for coord in GeoInterface.coordinates(sun_difference)[1]]
        hatch(poly(points, :stroke), 45, 2.0)
    end
end width height